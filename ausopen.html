<!DOCTYPE html>
<html>
  <head> 
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <style>
        .bar {
          fill: steelblue;
        }
    
        .bar:hover {
          fill: brown;
        }
    </style>
  </head>
  <body>
    <p>Hello!</p>
    <div id="chart1"></div>
    <div id="chart2"></div>

    <svg width="960" height="500"></svg>
    <script>
        let data;
        d3.csv("data/10yearAUSOpenMatches.csv", function(d) {
            return {
                round: d.round,
                roundNo: getRoundNo(d.round),
                winner: d.winner,
                results: d.results,
                year: +d.year,
                player1: d.player1,
                player2: d.player2,
                country1: d.country1,
                country2: d.country2,
                firstServe1: +d.firstServe1.substring(0, d.firstServe1.length - 1),
                firstServe2: +d.firstServe2.substring(0, d.firstServe2.length - 1),
                ace1: +d.ace1,
                ace2: +d.ace2,
                double1: +d.double1,
                double2: +d.double2,
                firstPointWon1: +d.firstPointWon1.substring(0, d.firstPointWon1.length - 1),
                firstPointWon2: +d.firstPointWon2.substring(0, d.firstPointWon2.length - 1),
                secPointWon1: +d.secPointWon1.substring(0, d.secPointWon1.length - 1),
                secPointWon2: +d.secPointWon2.substring(0, d.secPointWon2.length - 1),
                fastServe1: +d.fastServe1,
                fastServe2: +d.fastServe2,
                avgFirstServe1: +d.avgFirstServe1,
                avgFirstServe2: +d.avgFirstServe2,
                avgSecServe1: +d.avgSecServe1,
                avgSecServe2: +d.avgSecServe2,
                break1: +d.break1.substring(0, d.break1.length - 1),
                break2: +d.break2.substring(0, d.break2.length - 1),
                return1: +d.return1.substring(0, d.return1.length - 1),
                return2: +d.return2.substring(0, d.return2.length - 1),
                total1: +d.total1,
                total2: +d.total2,
                winner1: +d.winner1,
                winner2: +d.winner2,
                error1: +d.error1,
                error2: +d.error2,
                net1: +d.net1.substring(0, d.net1.length - 1),
                net2: +d.net2.substring(0, d.net2.length - 1),
            };
        }).then(function(d) {
            data = d;
            // console.log(data[0]);
            barChart();
        });

        function getRoundNo(round) {
            return round == 'First' ? 1 :
                    round == 'Second' ? 2 :
                    round == 'Third' ? 3 :
                    round == 'Fourth' ? 4 :
                    round == 'quarter' ? 5 :
                    round == 'semi' ? 6 : 7
        }

        function barChart() {
            // console.log(data[0])
            let most_wins = d3.nest()
                            .key(function (d) {return d.winner })
                            .rollup(function (d) { return d.length })
                            .entries(data);
            
            let sorted_data = most_wins.sort(function (d1, d2) {
                return d2.value - d1.value
            });

            let sliced_data = sorted_data.slice(0, 10);
            // console.log(sliced_data)
                    
            var svg = d3.select("svg"),
            margin = {
                top: 20,
                right: 20,
                bottom: 30,
                left: 50
            },
            width = +svg.attr("width") - margin.left - margin.right,
            height = +svg.attr("height") - margin.top - margin.bottom,
            g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            var x = d3.scaleBand()
                .rangeRound([0, width])
                .padding(0.1);

            var y = d3.scaleLinear()
                .rangeRound([height, 0]);

            x.domain(sliced_data.map(function (d) {
                return d.key;
            }));
            y.domain([0, d3.max(sliced_data, function (d) {
                return d.value;
            })]);

            g.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x))

            g.append("g")
            .call(d3.axisLeft(y))
            .append("text")
            .attr("fill", "#000")
            .attr("transform", "rotate(-90)")
            .attr("y", 6)
            .attr("dy", "0.71em")
            .attr("text-anchor", "end")
            .text("Wins");

            g.selectAll(".bar")
            .data(sliced_data)
            .enter()
            .append("rect")
            .attr("class", "bar")
            .attr("x", function (d) {
                return x(d.key);
            })
            .attr("y", function (d) {
                return y(d.value);
            })
            .attr("width", x.bandwidth())
            .attr("height", function (d) {
                return height - y(d.value);
            });

            svg.selectAll(".bar").on('click', function(d, i) {
                showPlayerPerformanceByYear(d)
                showPlayerAttributes(d)
            });

        }

        function showPlayerPerformanceByYear(player) {
            // console.log(player)
            
            let user_data = data.filter(function (d) {
                if (d.winner == player.key) {
                    return d
                }
            })

            let user_data_2 = d3.nest()
                .key(function(d) { return d.year; })
                .rollup(function (d) { return d.length })
                .entries(user_data)

            user_data_2 = user_data_2.sort(function (d1, d2) {
                return d2.key - d1.key
            });

            // console.log(user_data_2)

            d3.select("svg").html("");
            
            var margin = {top: 20, right: 20, bottom: 30, left: 40},
                width = 480 - margin.left - margin.right,
                height = 250 - margin.top - margin.bottom;

            // set the ranges
            var y = d3.scaleBand()
                    .range([height, 0])
                    .padding(0.1);

            var x = d3.scaleLinear()
                    .range([0, width]);
                    
            // append the svg object to the body of the page
            // append a 'group' element to 'svg'
            // moves the 'group' element to the top left margin
            // var svg = d3.select("svg")//.append("svg")
            var svg = d3.select("#chart1").append("svg")//.append("svg")
                .attr("width", width + margin.left + margin.right + 100)
                .attr("height", height + margin.top + margin.bottom)
            .append("g")
                .attr("transform", 
                    "translate(" + margin.left + "," + margin.top + ")");

            // Scale the range of the data in the domains
            x.domain([0, d3.max(user_data_2, function(d){ return d.value; })])
            y.domain(user_data_2.map(function(d) { return d.key; }));

            // append the rectangles for the bar chart
            var bars = svg.selectAll(".bar")
                .data(user_data_2)
                .enter().append("g")
            
            bars.append("rect")
                .attr("class", "bar")
                .attr("height", y.bandwidth())
                .attr("y", function(d) { return y(d.key); })
                .attr("width", 0)
                .transition()
                .duration(1500)//time in ms
                .attr("width", function(d) {return x(d.value); } )
                
                

            bars
                .data(user_data_2)
                .enter()
                .append("text")

            bars
                // .data(user_data_2)
                // .enter()
                .append("text")        
                .attr("y", function(d) {
                    return y(d.key) + y.bandwidth() / 2 + 4;
                })
                .attr("x", 10)
                .text(function(d) {
                    // return d.value
                    return d.value == 1 ? "First round" :
                        d.value == 2 ? "Second round" :
                        d.value == 3 ? "Third round" :
                        d.value == 4 ? "Fourth round" :
                        d.value == 5 ? "Quarter finalist" :
                        d.value == 6 ? "Runner up" : "Winner!"
                        
                })
                .attr("x", 0)
                .transition()
                .duration(1500)//time in ms
                .attr("x", function(d) {
                    return x(d.value) + 10;
                });
        
            

            // add the x Axis
            // svg.append("g")
            //     .attr("transform", "translate(0," + height + ")")
            //     .call(d3.axisBottom(x));

            // add the y Axis
            svg.append("g")
                .call(d3.axisLeft(y));

        }

        function showPlayerAttributes(player) {
            var groupData = constructData(player);
            
            // d3.select("svg").html("");

            var margin = {top: 20, right: 20, bottom: 30, left: 40},
            width = 800 - margin.left - margin.right,
            height = 400 - margin.top - margin.bottom;

            var x0  = d3.scaleBand().rangeRound([0, width], .5);
            var x1  = d3.scaleBand();
            var y   = d3.scaleLinear().rangeRound([height, 0]);

            var xAxis = d3.axisBottom().scale(x0)
                                        // .tickFormat(d3.timeFormat("Week %V"))
                                        .tickValues(groupData.map(d=>d.key));

            var yAxis = d3.axisLeft().scale(y);

            const color = d3.scaleOrdinal(d3.schemeCategory10);

            var svg = d3.select("#chart2").append("svg")
            // var svg = d3.select("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            var categoriesNames = groupData.map(function(d) { return d.key; });
            var rateNames       = groupData[0].values.map(function(d) { return d.name; });

            x0.domain(categoriesNames);
            x1.domain(rateNames).rangeRound([0, x0.bandwidth() / 1.1]);
            y.domain([0, d3.max(groupData, function(key) { return d3.max(key.values, function(d) { return d.value; }); })]);

            svg.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis);


            svg.append("g")
            .attr("class", "y axis")
            .style('opacity','0')
            .call(yAxis)
                .append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", 6)
                    .attr("dy", ".71em")
                    .style("text-anchor", "end")
                    .style('font-weight','bold')
                    .text("Value");

            svg.select('.y').transition().duration(500).delay(1300).style('opacity','1');

            var slice = svg.selectAll(".slice")
            .data(groupData)
            .enter().append("g")
            .attr("class", "g")
            .attr("transform",function(d) { return "translate(" + x0(d.key) + ",0)"; });

            slice.selectAll("rect")
            .data(function(d) { return d.values; })
                .enter().append("rect")
                    .attr("width", x1.bandwidth())
                    .attr("x", function(d) { return x1(d.name); })
                    .style("fill", function(d) { return color(d.name) })
                    .attr("y", function(d) { return y(0); })
                    .attr("height", function(d) { return height - y(0); })
                    .style("margin-right", "20px")
                    .on("mouseover", function(d) {
                        d3.select(this).style("fill", d3.rgb(color(d.name)).darker(2));
                    })
                    .on("mouseout", function(d) {
                        d3.select(this).style("fill", color(d.name));
                    });


            slice.selectAll("rect")
            .transition()
            .delay(function (d) {return Math.random()*1000;})
            .duration(1000)
            .attr("y", function(d) { return y(d.value); })
            .attr("height", function(d) { return height - y(d.value); });

            //Legend
            var legend = svg.selectAll(".legend")
                .data(groupData[0].values.map(function(d) { return d.name; }).reverse())
            .enter().append("g")
                .attr("class", "legend")
                .attr("transform", function(d,i) { return "translate(0," + i * 20 + ")"; })
                .style("opacity","0");

            legend.append("rect")
                .attr("x", width - 18)
                .attr("width", 18)
                .attr("height", 18)
                .style("fill", function(d) { return color(d); });

            legend.append("text")
                .attr("x", width - 24)
                .attr("y", 9)
                .attr("dy", ".35em")
                .style("text-anchor", "end")
                .text(function(d) {return d; });

            legend.transition().duration(500).delay(function(d,i){ return 1300 + 100 * i; }).style("opacity","1");

        }

        function constructData(player) {
            let player_data = getPlayerAttributes(player)
            let avg_stats = getAverageStats();

            return [
                {
                    key: 'firstServe', values: [
                        { name: player.key, value: d3.mean(player_data, function(d) { return d.firstServe; }) },
                        { name: 'avg', value: avg_stats.firstServe}
                    ]
                },
                {
                    key: 'firstPointWon', values: [
                        { name: player.key, value: d3.mean(player_data, function(d) { return d.firstPointWon; }) },
                        { name: 'avg', value: avg_stats.firstPointWon}
                    ]
                },
                {
                    key: 'secPointWon', values: [
                        { name: player.key, value: d3.mean(player_data, function(d) { return d.secPointWon; }) },
                        { name: 'avg', value: avg_stats.secPointWon}
                    ]
                },
                {
                    key: 'break', values: [
                        { name: player.key, value: d3.mean(player_data, function(d) { return d.break; }) },
                        { name: 'avg', value: avg_stats.break}
                    ]
                },
                {
                    key: 'return', values: [
                        { name: player.key, value: d3.mean(player_data, function(d) { return d.return; }) },
                        { name: 'avg', value: avg_stats.return}
                    ]
                },
                {
                    key: 'net', values: [
                        { name: player.key, value: d3.mean(player_data, function(d) { return d.net; }) },
                        { name: 'avg', value: avg_stats.net}
                    ]
                }
            ]
        }
        
        function getPlayerAttributes(player) {
            let player_data = data
                .filter(function (d) {
                    if (d.player1 == player.key || d.player2 == player.key) {
                        return d
                    }
                })
                .map(function (d) {
                    if (d.player1 == player.key) {
                        return {
                            player: d.player1,
                            won: d.player1 == d.winner,
                            year: d.year,
                            firstServe: d.firstServe1,
                            ace: d.ace1,
                            double: d.double1,
                            firstPointWon: d.firstPointWon1,
                            secPointWon: d.secPointWon1,
                            fastServe: d.fastServe1,
                            avgFirstServe: d.avgFirstServe1,
                            avgSecServe: d.avgSecServe1,
                            break: d.break1,
                            return: d.return1,
                            total: d.total1,
                            winner: d.winner1,
                            error: d.error1,
                            net: d.net1
                        };
                    } else if (d.player2 == player.key) {
                        return {
                            player: d.player2,
                            won: d.player2 == d.winner,
                            year: d.year,
                            firstServe: d.firstServe2,
                            ace: d.ace2,
                            double: d.double2,
                            firstPointWon: d.firstPointWon2,
                            secPointWon: d.secPointWon2,
                            fastServe: d.fastServe2,
                            avgFirstServe: d.avgFirstServe2,
                            avgSecServe: d.avgSecServe2,
                            break: d.break2,
                            return: d.return2,
                            total: d.total2,
                            winner: d.winner2,
                            error: d.error2,
                            net: d.net2
                        };
                    }
                })

            return player_data;
        }

        function getAverageStats() {
            return {
                firstServe: Math.ceil( (d3.mean(data, function(d) { return d.firstServe1; }) + d3.mean(data, function(d) { return d.firstServe2; })) / 2),
                ace: Math.ceil( (d3.mean(data, function(d) { return d.ace1; }) + d3.mean(data, function(d) { return d.ace2; })) / 2),
                double: Math.ceil( (d3.mean(data, function(d) { return d.double1; }) + d3.mean(data, function(d) { return d.double2; })) / 2),
                firstPointWon: Math.ceil( (d3.mean(data, function(d) { return d.firstPointWon1; }) + d3.mean(data, function(d) { return d.firstPointWon2; })) / 2),
                secPointWon: Math.ceil( (d3.mean(data, function(d) { return d.secPointWon1; }) + d3.mean(data, function(d) { return d.secPointWon2; })) / 2),
                fastServe: Math.ceil( (d3.mean(data, function(d) { return d.fastServe1; }) + d3.mean(data, function(d) { return d.fastServe2; })) / 2),
                avgFirstServe: Math.ceil( (d3.mean(data, function(d) { return d.avgFirstServe1; }) + d3.mean(data, function(d) { return d.avgFirstServe2; })) / 2),
                avgSecServe: Math.ceil( (d3.mean(data, function(d) { return d.avgSecServe1; }) + d3.mean(data, function(d) { return d.avgSecServe2; })) / 2),
                break: Math.ceil( (d3.mean(data, function(d) { return d.break1; }) + d3.mean(data, function(d) { return d.break2; })) / 2),
                return: Math.ceil( (d3.mean(data, function(d) { return d.return1; }) + d3.mean(data, function(d) { return d.return2; })) / 2),
                total: Math.ceil( (d3.mean(data, function(d) { return d.total1; }) + d3.mean(data, function(d) { return d.total2; })) / 2),
                winner: Math.ceil( (d3.mean(data, function(d) { return d.winner1; }) + d3.mean(data, function(d) { return d.winner2; })) / 2),
                error: Math.ceil( (d3.mean(data, function(d) { return d.error1; }) + d3.mean(data, function(d) { return d.error2; })) / 2),
                net: Math.ceil( (d3.mean(data, function(d) { return d.net1; }) + d3.mean(data, function(d) { return d.net2; })) / 2),
            }
        }

    </script>
  </body>
</html>
